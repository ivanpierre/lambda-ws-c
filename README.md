lambda-ws-c
===========

Project evolved a lot and goes in another direction... so documentation is to be completely rewritten...

Ideas
-----

Define data elements of a language as an AST system. The whole in C.

Somewhere it's like quantum against relativist physics.

Simple elements are complex to use but you can manage them with a simple, short code treatments. They are bricks of this AST system. But the goal is to manage complex compound made of these bricks, worse, you will use the brick behavior to create their behavior. Where is the border between simple and compound objects. When does, the language emerges out of elements that should be able to create any languages.

Perhaps is it an utopy. Perhaps languages are not made of simple bricks, general enough to generate all generalizations. Perhaps, the middle cement that glue all these bricks are between bricks and structures emerging from them.

Desires, knowledge, experience and experiments make from this mold an interesting journey. Retain one's tendency to go in known paths, do not be afraid to test and make errors, in order to discover some others, this is not always an easy way.

Why C ?
-------

Well, because evolving from quite the beginning, long years ago, from the BASIC of my youth, quickly passing to assembler, FORTRAN, FORTH, Pascal, Algol... I quickly search around some other paradigms APL, LISP, PROLOG. But because of the lack of experience, I didn't really got the differences, didn't found the particular idiomatic ways they express themselves.

As my first professional language, I worked in C. I liked to call it a "structured assembler". I'm not proud to say it was the hard way. It was just the only way there was... K&R, some books found here and there, technical books to figure out how to manage UNIX, DOS... manuals from database vendors to manage their software in C, in a less or more tricky fashion... No internet, no mail... I still ask myself how we achieved to write 200 or 500 thousand of lines of code this way. And more wondering how all this stuff could work :D

Well, long years ago. In the mean time, enthousiasm and discoveries, disapointments and depression were the peebles on witch every programmers put it's feets to traverse the river of our programming difficulties. Looking behind to discover how much was made, how easier the new tools made the work for us.

OOP a solution ?
----------------

As structured programmingwas seen as a real (and obvious afterward) enhancement in our code, the goto were blamed for their awful spagghetti code habit generation. Even FORTRAN take the structural habit. Functional way to see the code seemed natural. But it was not clear what exactly a funtion was. Procedures were still a function that return nothing and function a procedure that returns something. Bad habits were taken, as accepting to use goto to go outside of a structured code when there was errors,witch was later taken as an "exception". Yes, the worm was in the fruit, but we weren't exctly knowing what the fruit was... neither what the worm was...

TO be continued...
